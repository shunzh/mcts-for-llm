{
    "summary": "This code calculates 1-Wasserstein distances between vectors and generates distributions using linear programs. It includes functions for cleaning and generating worst-case distributions, along with a function that iteratively finds and cleans distributions.",
    "details": [
        {
            "comment": "This code file contains three functions related to distributions. The `marginal_matrices` function returns two matrices, A and B, used in the computation of Wasserstein distances. The `wass_primal` function computes the 1-Wasserstein distance between two vectors u and v using the primal formulation, utilizing the marginal matrices. Similarly, the `wass_dual` function computes the same distance using the dual formulation. All functions take a distances matrix d as input, which contains pairwise distances between elements of vectors u and v.",
            "location": "\"/media/root/Prima/works/mcts-for-llm/docs/src/dyna_gym/utils/distribution.py\":0-37",
            "content": "\"\"\"\nHelpful functions when dealing with distributions\n\"\"\"\nimport numpy as np\nimport dyna_gym.utils.utils as utils\nfrom itertools import combinations\nfrom scipy.optimize import linprog\nfrom math import sqrt\ndef marginal_matrices(n):\n    A = np.zeros(shape=(n, n**2))\n    B = np.zeros(shape=(n, n**2))\n    for i in range(n):\n        A[i][i*n:(i+1)*n] = 1\n        for j in range(n):\n            B[i][j*n+i] = 1\n    return A, B\ndef wass_primal(u, v, d):\n    \"\"\"\n    Compute the 1-Wasserstein distance between u (shape=n) and v (shape=n) given the distances matrix d (shape=(n,n)).\n    Use the primal formulation.\n    \"\"\"\n    n = d.shape[0]\n    obj = np.reshape(d, newshape=(n*n))\n    A, B = marginal_matrices(n)\n    Ae = np.concatenate((A, B), axis=0)\n    be = np.concatenate((u, v))\n    res = linprog(obj, A_eq=Ae, b_eq=be)\n    return res.fun\ndef wass_dual(u, v, d):\n    \"\"\"\n    Compute the 1-Wasserstein distance between u (shape=n) and v (shape=n) given the distances matrix d (shape=(n,n)).\n    Use the dual formulation.\n    \"\"\"\n    n = d.shape[0]"
        },
        {
            "comment": "The code contains three functions: `distribution`, `random_tabular`, and `random_constrained`. The `distribution` function generates a linear program to find the optimal distribution, while `random_tabular` generates a 1D numpy array whose coefficients sum to 1. Lastly, `random_constrained` randomly generates a new distribution with a specified Wasserstein distance threshold from the input distribution and uses a given distances matrix for comparison.",
            "location": "\"/media/root/Prima/works/mcts-for-llm/docs/src/dyna_gym/utils/distribution.py\":38-66",
            "content": "    comb = np.array(list(combinations(range(n), 2)))\n    obj = u - v\n    Au = np.zeros(shape=(n*(n-1),n))\n    bu = np.zeros(shape=(n*(n-1)))\n    for i in range(len(comb)):\n        Au[2*i][comb[i][0]] = +1.0\n        Au[2*i][comb[i][1]] = -1.0\n        Au[2*i+1][comb[i][0]] = -1.0\n        Au[2*i+1][comb[i][1]] = +1.0\n        bu[2*i] = d[comb[i][0]][comb[i][1]]\n        bu[2*i+1] = d[comb[i][0]][comb[i][1]]\n    res = linprog(obj, A_ub=Au, b_ub=bu)\n    return -res.fun\ndef random_tabular(size):\n    \"\"\"\n    Generate a 1D numpy array whose coefficients sum to 1\n    \"\"\"\n    w = np.random.random(size)\n    return w / np.sum(w)\ndef random_constrained(u, d, maxdist):\n    \"\"\"\n    Randomly generate a new distribution st the Wasserstein distance between the input\n    distribution u and the generated distribution is smaller than the input maxdist.\n    The distance is computed w.r.t. the distances matrix d.\n    Notice that the generated distribution has the same support as the input distribution.\n    \"\"\"\n    max_n_trial = int(1e4) # Maximum number of trials"
        },
        {
            "comment": "The code defines three functions: `clean_distribution`, `worstcase_distribution_dichotomy_method`. The `clean_distribution` function sets any weights close to zero to 0.0 and checks for negative weights. The `worstcase_distribution_dichotomy_method` function creates a worst-case distribution, returns it if the worst-case was found, or iteratively generates new distributions until it reaches the maximum number of trials. It also has checks for instabilities above a certain dimension and for zero or identical vectors. The code uses numpy arrays and other functions from the `utils` module.",
            "location": "\"/media/root/Prima/works/mcts-for-llm/docs/src/dyna_gym/utils/distribution.py\":67-98",
            "content": "    val = np.asarray(range(len(u)))\n    v = random_tabular(val.size)\n    for i in range(max_n_trial):\n        if wass_dual(u, v, d) <= maxdist:\n            return v\n        else:\n            v = random_tabular(val.size)\n    print('Failed to generate constrained distribution after {} trials'.format(max_n_trial))\n    exit()\ndef clean_distribution(w):\n    for i in range(len(w)):\n        if utils.close(w[i], 0.0):\n            w[i] = 0.0\n        else:\n            assert w[i] > 0.0, 'Error: negative weight computed ({}th index): w={}'.format(i, w)\n    return w\ndef worstcase_distribution_dichotomy_method(v, w0, c, d):\n    time_start = time.time()\n    n = len(v)\n    if n > 28:\n        print('WARNING: solver instabilities above this number of dimensions (n={})'.format(n))\n    if utils.close(c, 0.0) or utils.closevec(v, v[0] * np.ones(n)):\n        return w0\n    w_worst = np.zeros(n)\n    w_worst[np.argmin(v)] = 1.0\n    if (wass_dual(w_worst, w0, d) <= c):\n        return w_worst\n    else:\n        wmax = w_worst\n        wmin = w0"
        },
        {
            "comment": "The provided code contains two functions: \"worstcase_distribution_direct_method\" and an anonymous function. The anonymous function initializes variables and performs iterative calculations to find a distribution that meets certain criteria. It checks if the given cost 'c' is close to 0 or if the vector 'v' is a scaled version of itself. If so, it returns the initial distribution 'w0'. Otherwise, it computes the worst-case distribution 'w_worst', calculates the Lagrange multiplier 'lbd', and iteratively updates the distribution 'w' based on 'w0' and 'w_worst' until convergence. Finally, it returns the cleaned distribution using \"clean_distribution\" function.",
            "location": "\"/media/root/Prima/works/mcts-for-llm/docs/src/dyna_gym/utils/distribution.py\":99-124",
            "content": "        w = 0.5 * (wmin + wmax)\n        for i in range(1000): # max iter is 1000\n            if (wass_dual(w, w0, d) <= c):\n                wmin = w\n                wnew = 0.5 * (wmin + wmax)\n            else:\n                wmax = w\n                wnew = 0.5 * (wmin + wmax)\n            if utils.closevec(wnew, w, 6): # precision is 1e-6\n                w = wnew\n                break\n            else:\n                w = wnew\n    return clean_distribution(w)\ndef worstcase_distribution_direct_method(v, w0, c, d):\n    n = len(v)\n    if utils.close(c, 0.0) or utils.closevec(v, v[0] * np.ones(n)):\n        return w0\n    w_worst = np.zeros(n)\n    w_worst[np.argmin(v)] = 1.0\n    if (wass_dual(w_worst, w0, d) <= c):\n        return w_worst\n    lbd = c / wass_dual(w0, w_worst, d)\n    w = w_an = (1.0 - lbd) * w0 + lbd * w_worst\n    return clean_distribution(w)"
        }
    ]
}